"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.call_dest = exports.call_src = exports.test_dest = exports.test_src = exports.deploy = void 0;
const settings_1 = require("./settings");
const node_fetch_1 = __importStar(require("node-fetch"));
const typescript_1 = require("typescript");
const deployer_1 = require("./deployer");
require("segment-typescript-definitions/common");
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
async function deploy(is_dev, access_token, work_slug, work_id, out_file, debug_url) {
    let settings = await settings_1.load_settings(settings_1.get_settings_file());
    let settings_js;
    if (settings.language == 'javascript') {
        settings_js = await fs.readFile(path.join(process.cwd(), 'src', 'settings.js'), 'utf8');
    }
    else {
        let settings_ts = await fs.readFile(path.join(process.cwd(), 'src', 'settings.ts'), 'utf8');
        settings_js = typescript_1.transpile(settings_ts, {
            target: typescript_1.ScriptTarget.ES2017
        });
    }
    // = await fs.readFile(settings.language == 'javascript' ? path.join(process.cwd(), 'src', 'settings.js') : path.join(process.cwd(), 'out', 'settings.js'), 'utf8')
    let optionalSettings = {};
    let requiredSettings = {};
    const secret = 'secret';
    const string = 'string';
    const array = 'array';
    const map = 'map';
    const boolean = 'boolean';
    function validate() { }
    eval(`${settings_js}
optionalSettings = OptionalSettings
requiredSettings = RequiredSettings`);
    if (settings.fn_type == 'source') {
        await deployer_1.deploy_source(settings, is_dev, requiredSettings, optionalSettings, access_token, work_slug, work_id, debug_url, out_file);
    }
    else {
        await deployer_1.deploy_destination(settings, is_dev, requiredSettings, optionalSettings, access_token, work_slug, work_id, debug_url, out_file);
    }
}
exports.deploy = deploy;
function urlArgsToString(urlArgs) {
    if (!urlArgs) {
        return '';
    }
    let keys = Object.keys(urlArgs);
    if (keys.length == 0) {
        return '';
    }
    let s = '?';
    keys.forEach(key => {
        let value = urlArgs[key];
        let value_str = value;
        s += '&' + key + '=' + value_str;
    });
    return s;
}
async function test_src(payload, settings, sam_port, sam_host) {
    if (typeof payload.body !== 'string') {
        payload.headers['Content-Type'] = 'application/json';
    }
    payload.settings = settings;
    let r = await node_fetch_1.default(`http://${sam_host || '127.0.0.1'}:${sam_port}/function`, {
        method: 'post',
        body: JSON.stringify(payload),
        headers: {
            'Content-Type': 'application/json'
        },
    });
    let j = await r.json();
    if (r.status == 200) {
        return j;
    }
    else {
        throw j;
    }
}
exports.test_src = test_src;
async function test_dest(event, settings, sam_port, sam_host) {
    let r = await node_fetch_1.default(`http://${sam_host || '127.0.0.1'}:${sam_port}/function`, {
        method: 'post',
        body: JSON.stringify({ event, settings }),
        headers: {
            'Content-Type': 'application/json'
        }
    });
    let j = await r.json();
    if (r.status == 200) {
        return j;
    }
    else {
        throw j;
    }
}
exports.test_dest = test_dest;
async function call_src(_payload, onRequest, output) {
    output.tracks = [];
    output.identifies = [];
    output.groups = [];
    output.aliases = [];
    output.screens = [];
    output.pages = [];
    global.Segment = {
        identify(i) {
            output.identifies.push(i);
        },
        track(t) {
            output.tracks.push(t);
        },
        group(t) {
            output.groups.push(t);
        },
        alias(t) {
            output.aliases.push(t);
        },
        page(t) {
            output.pages.push(t);
        },
        screen(t) {
            output.screens.push(t);
        }
    };
    let payload = JSON.parse(_payload.body);
    let body = payload.body;
    const settings = payload.settings;
    await onRequest({
        json() {
            return JSON.parse(body);
        },
        text() {
            return body;
        },
        headers: new node_fetch_1.Headers(payload.headers),
        // TODO: This mimics the Segment Test approach. I suspect no one uses this in reality, but does this need to match the actual URL called by the test?
        url: new URL('https://fn.segmentapis.com/' + urlArgsToString(payload.queryParameters))
    }, settings);
}
exports.call_src = call_src;
async function call_dest(_event, fns) {
    const event_and_settings = JSON.parse(_event.body);
    const event = event_and_settings.event;
    const settings = event_and_settings.settings;
    switch (event.type) {
        case 'alias': {
            if (fns.onAlias) {
                await fns.onAlias(event, settings);
            }
            break;
        }
        case 'identify': {
            if (fns.onIdentify) {
                await fns.onIdentify(event, settings);
            }
            break;
        }
        case 'page': {
            if (fns.onPage) {
                await fns.onPage(event, settings);
            }
            break;
        }
        case 'screen': {
            if (fns.onScreen) {
                await fns.onScreen(event, settings);
            }
            break;
        }
        case 'track': {
            if (fns.onTrack) {
                await fns.onTrack(event, settings);
            }
            break;
        }
        case 'group': {
            if (fns.onGroup) {
                await fns.onGroup(event, settings);
            }
            break;
        }
    }
}
exports.call_dest = call_dest;
//# sourceMappingURL=index.js.map