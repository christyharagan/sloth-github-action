"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build_function = exports.deploy_destination = exports.deploy_source = exports.get_js = void 0;
const typescript_1 = require("typescript");
const config_api_1 = require("segment-typescript-api/cjs/config_api");
const fs = __importStar(require("fs-extra"));
const settings_1 = require("./settings");
const webpack_1 = require("./webpack");
async function get_js(settings) {
    let fn_path = settings_1.get_source_file(settings);
    if (settings.language == 'typescript') {
        let ts = await fs.readFile(fn_path, 'utf8');
        return typescript_1.transpile(ts, {
            target: typescript_1.ScriptTarget.ES2017
        });
    }
    else {
        return await fs.readFile(fn_path, 'utf8');
    }
}
exports.get_js = get_js;
async function deploy_source(settings, is_dev, req_fn_settings, op_fn_settings, access_token, work_slug, work_id, debug_url, out_file) {
    if (!(work_slug || settings.work_slug) || !(settings.work_id || work_id) || !(settings.access_token || access_token)) {
        throw 'Cannot deploy without workspace Slug, workspace ID, and access token';
    }
    let js = '';
    if (debug_url) {
        if (debug_url.charAt(debug_url.length - 1)) {
            debug_url = debug_url + '/';
        }
        js = `
async function onRequest(request, settings) {
  let headers = {}
  let body = await request.text()
  request.headers.forEach((v, k) => {
    headers[k] = v
  })
  let queryParams = {}
  request.url.searchParams.forEach((value, key) => {
    queryParams[key] = value
  })
  let payload = {
    headers,
    body,
    settings,
    queryParams
  }
  return fetch('${debug_url}', {
    method: 'post',
    body: JSON.stringify(payload),
    headers: {
      'Content-Type': 'application/json'
    }
  })
}`;
    }
    else {
        js = await get_js(settings);
        js = await webpack_1.pack(js, true, is_dev);
    }
    if (out_file) {
        await fs.writeFile(out_file, js, 'utf8');
    }
    else {
        await build_function(settings.fn_name, true, (work_slug || settings.work_slug), (work_id || settings.work_id), js, (access_token || settings.access_token), convert_function_settings(req_fn_settings, op_fn_settings));
    }
}
exports.deploy_source = deploy_source;
function to_camel_case(input) {
    let regex = /[A-Z\xC0-\xD6\xD8-\xDE]?[a-z\xDF-\xF6\xF8-\xFF]+|[A-Z\xC0-\xD6\xD8-\xDE]+(?![a-z\xDF-\xF6\xF8-\xFF])|\d+/g;
    let words = input.match(regex);
    if (words) {
        return words.reduce((result, word, i) => {
            let temp = word.toLowerCase();
            return result + (i == 0 ? temp : (temp = temp.substr(0, 1).toUpperCase() + temp.substr(1)));
        }, '');
    }
    else {
        throw 'Regex didnt match';
    }
}
function to_snake_case(string) {
    let words = string.match(/[A-Z]{2,}(?=[A-Z][a-z]+[0-9]*|\b)|[A-Z]?[a-z]+[0-9]*|[A-Z]|[0-9]+/g);
    if (words) {
        return words.map(word => word.toLowerCase()).join('_');
    }
    else {
        throw 'Regex didnt match';
    }
}
function build_setting(k, v) {
    let setting = {
        name: to_camel_case(k),
        label: to_snake_case(k),
        type: 'string'
    };
    if (typeof v !== 'string') {
        setting.description = v.description;
        v = v.type;
    }
    switch (v) {
        case 'array': {
            setting.type = 'array';
            break;
        }
        case 'boolean': {
            setting.type = 'boolean';
            break;
        }
        case 'map': {
            setting.type = 'text-map';
            break;
        }
        case 'secret': {
            setting.sensitive = true;
            break;
        }
    }
    return setting;
}
function convert_function_settings(req_fn_settings, op_fn_settings) {
    let output = [];
    if (req_fn_settings) {
        Object.keys(req_fn_settings).forEach(k => {
            let v = req_fn_settings[k];
            let s = build_setting(k, v);
            s.required = true;
            output.push(s);
        });
    }
    if (op_fn_settings) {
        Object.keys(op_fn_settings).forEach(k => {
            let v = op_fn_settings[k];
            let s = build_setting(k, v);
            output.push(s);
        });
    }
    return req_fn_settings || op_fn_settings ? output : undefined;
}
async function deploy_destination(settings, is_dev, req_fn_settings, op_fn_settings, access_token, work_slug, work_id, debug_url, out_file) {
    if (!(work_slug || settings.work_slug) || !(settings.work_id || work_id) || !(settings.access_token || access_token)) {
        throw 'Cannot deploy without workspace ID and access token';
    }
    let js = '';
    if (debug_url) {
        js = `async function onTrack(event, settings) {
  await fetch('${debug_url}', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      event, settings
    })
  })
}
async function onIdentify(event, settings) {
  await fetch('${debug_url}', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      event, settings
    })
  })
}
async function onAlias(event, settings) {
  await fetch('${debug_url}', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      event, settings
    })
  })
}
async function onPage(event, settings) {
  await fetch('${debug_url}', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      event, settings
    })
  })
}
async function onScreen(event, settings) {
  await fetch('${debug_url}', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      event, settings
    })
  })
}
async function onGroup(event, settings) {
  await fetch('${debug_url}', {
    method: 'post',
    headers: {
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      event, settings
    })
  })
}`;
    }
    else {
        js = await get_js(settings);
        js = await webpack_1.pack(js, false, is_dev);
    }
    if (out_file) {
        await fs.writeFile(out_file, js, 'utf8');
    }
    else {
        await build_function(settings.fn_name, false, (work_slug || settings.work_slug), (work_id || settings.work_id), js, (access_token || settings.access_token), convert_function_settings(req_fn_settings, op_fn_settings));
    }
}
exports.deploy_destination = deploy_destination;
async function build_function(fn_name, is_src, work_slug, work_id, code, access_token, settings, dont_overwrite) {
    let wks = is_src ? '' : (await config_api_1.getWorkspace(access_token, work_slug)).display_name;
    let fns = await config_api_1.listFunctions(access_token, work_id, { type: is_src ? 'SOURCE' : 'DESTINATION', page_size: 100 });
    let fn = fns.functions ? fns.functions.find(fn => fn.display_name == (is_src ? fn_name : fn_name + ' (' + wks + ')')) : undefined;
    if (fn) {
        if (dont_overwrite) {
            return false;
        }
        let _fn = fn;
        let r = await config_api_1.updateFunction(access_token, work_id, _fn.id, {
            function: Object.assign(Object.assign({}, settings ? { settings } : {}), { code, buildpack: 'boreal' }),
            update_mask: {
                paths: ['function.code', 'function.buildpack', ...settings ? ['function.settings'] : []]
            }
        });
        return r.id;
    }
    else {
        let r = await config_api_1.createFunction(access_token, work_id, is_src ? 'SOURCE' : 'DESTINATION', Object.assign(Object.assign({}, settings ? { settings } : {}), { code, buildpack: 'boreal', display_name: fn_name }));
        return r.id;
    }
}
exports.build_function = build_function;
//# sourceMappingURL=deployer.js.map