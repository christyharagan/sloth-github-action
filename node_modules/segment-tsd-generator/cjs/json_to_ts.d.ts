import { JSONSchema4, JSONSchema4Type, JSONSchema4TypeName } from 'json-schema';
import $RefParser = require('json-schema-ref-parser');
export interface JSONSchema extends JSONSchema4 {
    /**
     * schema extension to support numeric enums
     */
    tsEnumNames?: string[];
    /**
     * schema extension to support custom types
     */
    tsType?: string;
}
export interface Options {
    /**
     * Disclaimer comment prepended to the top of each generated file.
     */
    bannerComment: string;
    /**
     * Root directory for resolving [`$ref`](https://tools.ietf.org/id/draft-pbryan-zyp-json-ref-03.html)s.
     */
    cwd: string;
    /**
     * Declare external schemas referenced via `$ref`?
     */
    declareExternallyReferenced: boolean;
    /**
     * Prepend enums with [`const`](https://www.typescriptlang.org/docs/handbook/enums.html#computed-and-constant-members)?
     */
    enableConstEnums: boolean;
    /**
     * Append all index signatures with `| undefined` so that they are strictly typed.
     *
     * This is required to be compatible with `strictNullChecks`.
     */
    strictIndexSignatures: boolean;
    /**
     * A [Prettier](https://prettier.io/docs/en/options.html) configuration.
     */
    style: any;
    /**
     * Generate code for `definitions` that aren't referenced by the schema?
     */
    unreachableDefinitions: boolean;
    /**
     * [$RefParser](https://github.com/BigstickCarpet/json-schema-ref-parser) Options, used when resolving `$ref`s
     */
    $refOptions: any;
}
export declare const DEFAULT_OPTIONS: Options;
export declare class ValidationError extends Error {
}
export declare function compile(schema: JSONSchema4, name: string, options?: Partial<Options>): Promise<string>;
export declare function traverse(schema: JSONSchema, callback: (schema: JSONSchema) => void): void;
export declare function dereference(schema: JSONSchema, { cwd, $refOptions }: {
    cwd: string;
    $refOptions: $RefParser.Options;
}): Promise<JSONSchema>;
export declare function mapDeep(object: object, fn: (value: object, key?: string) => object, key?: string): object;
export declare function error(...messages: any[]): void;
export declare function log(...messages: any[]): void;
export declare function format(code: string, options: Options): string;
export declare function generate(ast: AST, options?: Options): string;
export declare type AST_TYPE = AST['type'];
export declare type AST = TAny | TArray | TBoolean | TEnum | TInterface | TNamedInterface | TIntersection | TLiteral | TNumber | TNull | TObject | TReference | TString | TTuple | TUnion | TCustomType;
export interface AbstractAST {
    comment?: string;
    keyName?: string;
    standaloneName?: string;
    type: AST_TYPE;
}
export declare type ASTWithComment = AST & {
    comment: string;
};
export declare type ASTWithName = AST & {
    keyName: string;
};
export declare type ASTWithStandaloneName = AST & {
    standaloneName: string;
};
export declare function hasComment(ast: AST): ast is ASTWithComment;
export declare function hasStandaloneName(ast: AST): ast is ASTWithStandaloneName;
export interface TAny extends AbstractAST {
    type: 'ANY';
}
export interface TArray extends AbstractAST {
    type: 'ARRAY';
    params: AST;
}
export interface TBoolean extends AbstractAST {
    type: 'BOOLEAN';
}
export interface TEnum extends AbstractAST {
    standaloneName: string;
    type: 'ENUM';
    params: TEnumParam[];
}
export interface TEnumParam {
    ast: AST;
    keyName: string;
}
export interface TInterface extends AbstractAST {
    type: 'INTERFACE';
    params: TInterfaceParam[];
    superTypes: TNamedInterface[];
}
export interface TNamedInterface extends AbstractAST {
    standaloneName: string;
    type: 'INTERFACE';
    params: TInterfaceParam[];
    superTypes: TNamedInterface[];
}
export interface TInterfaceParam {
    ast: AST;
    keyName: string;
    isRequired: boolean;
    isPatternProperty: boolean;
    isUnreachableDefinition: boolean;
}
export interface TIntersection extends AbstractAST {
    type: 'INTERSECTION';
    params: AST[];
}
export interface TLiteral extends AbstractAST {
    params: JSONSchema4Type;
    type: 'LITERAL';
}
export interface TNumber extends AbstractAST {
    type: 'NUMBER';
}
export interface TNull extends AbstractAST {
    type: 'NULL';
}
export interface TObject extends AbstractAST {
    type: 'OBJECT';
}
export interface TReference extends AbstractAST {
    type: 'REFERENCE';
    params: string;
}
export interface TString extends AbstractAST {
    type: 'STRING';
}
export interface TTuple extends AbstractAST {
    type: 'TUPLE';
    params: AST[];
    spreadParam?: AST;
    minItems: number;
    maxItems?: number;
}
export interface TUnion extends AbstractAST {
    type: 'UNION';
    params: AST[];
}
export interface TCustomType extends AbstractAST {
    type: 'CUSTOM_TYPE';
    params: string;
}
export declare const T_ANY: TAny;
export declare const T_ANY_ADDITIONAL_PROPERTIES: TAny & ASTWithName;
export declare function toSafeString(string: string): string;
export declare function optimize(ast: AST, processed?: Map<AST, AST>): AST;
export declare type Processed = Map<JSONSchema | JSONSchema4Type, AST>;
export declare type UsedNames = Set<string>;
export declare function parse(schema: JSONSchema | JSONSchema4Type, options: Options, rootSchema?: JSONSchema, keyName?: string, isSchema?: boolean, processed?: Processed, usedNames?: Set<string>): AST;
/**
 * Duck types a JSONSchema schema or property to determine which kind of AST node to parse it into.
 */
export declare function typeOfSchema(schema: JSONSchema): SCHEMA_TYPE;
export declare function generateName(from: string, usedNames: Set<string>): string;
export declare type SCHEMA_TYPE = 'ALL_OF' | 'UNNAMED_SCHEMA' | 'ANY' | 'ANY_OF' | 'BOOLEAN' | 'NAMED_ENUM' | 'NAMED_SCHEMA' | 'NULL' | 'NUMBER' | 'STRING' | 'OBJECT' | 'ONE_OF' | 'TYPED_ARRAY' | 'REFERENCE' | 'UNION' | 'UNNAMED_ENUM' | 'UNTYPED_ARRAY' | 'CUSTOM_TYPE';
export declare type JSONSchemaTypeName = JSONSchema4TypeName;
export interface JSONSchema extends JSONSchema4 {
    /**
     * schema extension to support numeric enums
     */
    tsEnumNames?: string[];
    /**
     * schema extension to support custom types
     */
    tsType?: string;
}
export interface NormalizedJSONSchema extends JSONSchema {
    additionalItems?: boolean | NormalizedJSONSchema;
    additionalProperties: boolean | NormalizedJSONSchema;
    items?: NormalizedJSONSchema | NormalizedJSONSchema[];
    definitions?: {
        [k: string]: NormalizedJSONSchema;
    };
    properties?: {
        [k: string]: NormalizedJSONSchema;
    };
    patternProperties?: {
        [k: string]: NormalizedJSONSchema;
    };
    dependencies?: {
        [k: string]: NormalizedJSONSchema | string[];
    };
    allOf?: NormalizedJSONSchema[];
    anyOf?: NormalizedJSONSchema[];
    oneOf?: NormalizedJSONSchema[];
    not?: NormalizedJSONSchema;
    required: string[];
}
export interface EnumJSONSchema extends NormalizedJSONSchema {
    enum: any[];
}
export interface NamedEnumJSONSchema extends NormalizedJSONSchema {
    tsEnumNames: string[];
}
export interface SchemaSchema extends NormalizedJSONSchema {
    properties: {
        [k: string]: NormalizedJSONSchema;
    };
    required: string[];
}
export interface JSONSchemaWithDefinitions extends NormalizedJSONSchema {
    definitions: {
        [k: string]: NormalizedJSONSchema;
    };
}
export interface CustomTypeJSONSchema extends NormalizedJSONSchema {
    tsType: string;
}
/**
 * Eg. `foo/bar/baz.json` => `baz`
 */
export declare function justName(filename?: string): string;
/**
 * Avoid appending "js" to top-level unnamed schemas
 */
export declare function stripExtension(filename: string): string;
/**
 * escape block comments in schema descriptions so that they don't unexpectedly close JSDoc comments in generated typescript interfaces
 */
export declare function escapeBlockComment(schema: JSONSchema): void;
export declare function normalize(schema: JSONSchema, filename?: string): NormalizedJSONSchema;
