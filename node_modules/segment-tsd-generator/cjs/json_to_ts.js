"use strict";
// All code except 'basename' and 'extname' taken from https://github.com/bcherny/json-schema-to-typescript
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalize = exports.escapeBlockComment = exports.stripExtension = exports.justName = exports.generateName = exports.typeOfSchema = exports.parse = exports.optimize = exports.toSafeString = exports.T_ANY_ADDITIONAL_PROPERTIES = exports.T_ANY = exports.hasStandaloneName = exports.hasComment = exports.generate = exports.format = exports.log = exports.error = exports.mapDeep = exports.dereference = exports.traverse = exports.compile = exports.ValidationError = exports.DEFAULT_OPTIONS = void 0;
const lodash_1 = require("lodash");
// import {format as prettify} from 'prettier'
const stringify = require("json-stringify-safe");
const $RefParser = require("json-schema-ref-parser");
exports.DEFAULT_OPTIONS = {
    $refOptions: {},
    bannerComment: `/* tslint:disable */
/**
* This file was automatically generated by json-schema-to-typescript.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run json-schema-to-typescript to regenerate this file.
*/`,
    cwd: process.cwd(),
    declareExternallyReferenced: true,
    enableConstEnums: true,
    strictIndexSignatures: false,
    style: {
        bracketSpacing: false,
        printWidth: 120,
        semi: true,
        singleQuote: false,
        tabWidth: 2,
        trailingComma: 'none',
        useTabs: false
    },
    unreachableDefinitions: false
};
class ValidationError extends Error {
}
exports.ValidationError = ValidationError;
async function compile(schema, name, options = {}) {
    const _options = lodash_1.merge({}, exports.DEFAULT_OPTIONS, options);
    const errors = validate(schema, name);
    if (errors.length) {
        errors.forEach(_ => error(_));
        throw new ValidationError();
    }
    // normalize options
    if (!lodash_1.endsWith(_options.cwd, '/')) {
        _options.cwd += '/';
    }
    return format(generate(optimize(parse(await dereference(normalize(schema, name), _options), _options)), _options), _options);
}
exports.compile = compile;
function traverseObjectKeys(obj, callback) {
    Object.keys(obj).forEach(k => {
        if (obj[k] && typeof obj[k] === 'object' && !Array.isArray(obj[k])) {
            traverse(obj[k], callback);
        }
    });
}
function traverseArray(arr, callback) {
    arr.forEach(i => traverse(i, callback));
}
function traverse(schema, callback) {
    callback(schema);
    if (schema.anyOf) {
        traverseArray(schema.anyOf, callback);
    }
    if (schema.allOf) {
        traverseArray(schema.allOf, callback);
    }
    if (schema.oneOf) {
        traverseArray(schema.oneOf, callback);
    }
    if (schema.properties) {
        traverseObjectKeys(schema.properties, callback);
    }
    if (schema.patternProperties) {
        traverseObjectKeys(schema.patternProperties, callback);
    }
    if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {
        traverse(schema.additionalProperties, callback);
    }
    if (schema.items) {
        const { items } = schema;
        if (Array.isArray(items)) {
            traverseArray(items, callback);
        }
        else {
            traverse(items, callback);
        }
    }
    if (schema.additionalItems && typeof schema.additionalItems === 'object') {
        traverse(schema.additionalItems, callback);
    }
    if (schema.dependencies) {
        traverseObjectKeys(schema.dependencies, callback);
    }
    if (schema.definitions) {
        traverseObjectKeys(schema.definitions, callback);
    }
    if (schema.not) {
        traverse(schema.not, callback);
    }
    // technically you can put definitions on any key
    Object.keys(schema)
        .filter(key => !BLACKLISTED_KEYS.has(key))
        .forEach(key => {
        const child = schema[key];
        if (child && typeof child === 'object') {
            traverseObjectKeys(child, callback);
        }
    });
}
exports.traverse = traverse;
// keys that shouldn't be traversed by the catchall step
const BLACKLISTED_KEYS = new Set([
    'id',
    '$schema',
    'title',
    'description',
    'default',
    'multipleOf',
    'maximum',
    'exclusiveMaximum',
    'minimum',
    'exclusiveMinimum',
    'maxLength',
    'minLength',
    'pattern',
    'additionalItems',
    'items',
    'maxItems',
    'minItems',
    'uniqueItems',
    'maxProperties',
    'minProperties',
    'required',
    'additionalProperties',
    'definitions',
    'properties',
    'patternProperties',
    'dependencies',
    'enum',
    'type',
    'allOf',
    'anyOf',
    'oneOf',
    'not'
]);
// export function normalize(schema: JSONSchema, filename?: string): NormalizedJSONSchema {
//   const _schema = cloneDeep(schema) as NormalizedJSONSchema
//   validator_rules.forEach((rule, key) => {
//     traverse(_schema, schema => rule(schema, _schema, filename))
//     log('normalizer', `Applied rule: "${key}"`)
//   })
//   return _schema
// }
async function dereference(schema, { cwd, $refOptions }) {
    log('resolver', schema, cwd);
    const parser = new $RefParser();
    return parser.dereference(cwd, schema, $refOptions);
}
exports.dereference = dereference;
function validate(schema, filename) {
    const errors = [];
    validator_rules.forEach((rule, ruleName) => {
        mapDeep(schema, (schema, key) => {
            if (rule(schema) === false) {
                errors.push(`Error at key "${key}" in file "${filename}": ${ruleName}`);
            }
            return schema;
        });
    });
    return errors;
}
const validator_rules = new Map();
validator_rules.set('Enum members and tsEnumNames must be of the same length', schema => {
    if (schema.enum && schema.tsEnumNames && schema.enum.length !== schema.tsEnumNames.length) {
        return false;
    }
});
validator_rules.set('tsEnumNames must be an array of strings', schema => {
    if (schema.tsEnumNames && schema.tsEnumNames.some(_ => typeof _ !== 'string')) {
        return false;
    }
});
validator_rules.set('When both maxItems and minItems are present, maxItems >= minItems', schema => {
    const { maxItems, minItems } = schema;
    if (typeof maxItems === 'number' && typeof minItems === 'number') {
        return maxItems >= minItems;
    }
});
validator_rules.set('When maxItems exists, maxItems >= 0', schema => {
    const { maxItems } = schema;
    if (typeof maxItems === 'number') {
        return maxItems >= 0;
    }
});
validator_rules.set('When minItems exists, minItems >= 0', schema => {
    const { minItems } = schema;
    if (typeof minItems === 'number') {
        return minItems >= 0;
    }
});
function mapDeep(object, fn, key) {
    return fn(lodash_1.mapValues(object, (_, key) => {
        if (lodash_1.isPlainObject(_)) {
            return mapDeep(_, fn, key);
        }
        else if (Array.isArray(_)) {
            return _.map(item => {
                if (lodash_1.isPlainObject(item)) {
                    return mapDeep(item, fn, key);
                }
                return item;
            });
        }
        return _;
    }), key);
}
exports.mapDeep = mapDeep;
function error(...messages) {
    console.error('error', ...messages);
}
exports.error = error;
function log(...messages) {
    if (process.env.VERBOSE) {
        console.info('debug', ...messages);
    }
}
exports.log = log;
function format(code, options) {
    // return prettify(code, {parser: 'typescript', ...options.style})
    return code;
}
exports.format = format;
function generate(ast, options = exports.DEFAULT_OPTIONS) {
    return ([
        options.bannerComment,
        declareNamedTypes(ast, options, ast.standaloneName),
        declareNamedInterfaces(ast, options, ast.standaloneName),
        declareEnums(ast, options)
    ]
        .filter(Boolean)
        .join('\n\n') + '\n'); // trailing newline
}
exports.generate = generate;
function hasComment(ast) {
    return 'comment' in ast && ast.comment != null && ast.comment !== '';
}
exports.hasComment = hasComment;
function hasStandaloneName(ast) {
    return 'standaloneName' in ast && ast.standaloneName != null && ast.standaloneName !== '';
}
exports.hasStandaloneName = hasStandaloneName;
////////////////////////////////////////////     literals
exports.T_ANY = {
    type: 'ANY'
};
exports.T_ANY_ADDITIONAL_PROPERTIES = {
    keyName: '[k: string]',
    type: 'ANY'
};
function declareEnums(ast, options, processed = new Set()) {
    if (processed.has(ast)) {
        return '';
    }
    processed.add(ast);
    let type = '';
    switch (ast.type) {
        case 'ENUM':
            type = generateStandaloneEnum(ast, options) + '\n';
            break;
        case 'ARRAY':
            return declareEnums(ast.params, options, processed);
        case 'TUPLE':
            type = ast.params.reduce((prev, ast) => prev + declareEnums(ast, options, processed), '');
            if (ast.spreadParam) {
                type += declareEnums(ast.spreadParam, options, processed);
            }
            break;
        case 'INTERFACE':
            type = getSuperTypesAndParams(ast).reduce((prev, ast) => prev + declareEnums(ast, options, processed), '');
            break;
        default:
            return '';
    }
    return type;
}
function declareNamedInterfaces(ast, options, rootASTName, processed = new Set()) {
    if (processed.has(ast)) {
        return '';
    }
    processed.add(ast);
    let type = '';
    switch (ast.type) {
        case 'ARRAY':
            type = declareNamedInterfaces(ast.params, options, rootASTName, processed);
            break;
        case 'INTERFACE':
            type = [
                hasStandaloneName(ast) &&
                    (ast.standaloneName === rootASTName || options.declareExternallyReferenced) &&
                    generateStandaloneInterface(ast, options),
                getSuperTypesAndParams(ast)
                    .map(ast => declareNamedInterfaces(ast, options, rootASTName, processed))
                    .filter(Boolean)
                    .join('\n')
            ]
                .filter(Boolean)
                .join('\n');
            break;
        case 'INTERSECTION':
        case 'TUPLE':
        case 'UNION':
            type = ast.params
                .map(_ => declareNamedInterfaces(_, options, rootASTName, processed))
                .filter(Boolean)
                .join('\n');
            if (ast.type === 'TUPLE' && ast.spreadParam) {
                type += declareNamedInterfaces(ast.spreadParam, options, rootASTName, processed);
            }
            break;
        default:
            type = '';
    }
    return type;
}
function declareNamedTypes(ast, options, rootASTName, processed = new Set()) {
    if (processed.has(ast)) {
        return '';
    }
    processed.add(ast);
    let type = '';
    switch (ast.type) {
        case 'ARRAY':
            type = [
                declareNamedTypes(ast.params, options, rootASTName, processed),
                hasStandaloneName(ast) ? generateStandaloneType(ast, options) : undefined
            ]
                .filter(Boolean)
                .join('\n');
            break;
        case 'ENUM':
            type = '';
            break;
        case 'INTERFACE':
            type = getSuperTypesAndParams(ast)
                .map(ast => (ast.standaloneName === rootASTName || options.declareExternallyReferenced) &&
                declareNamedTypes(ast, options, rootASTName, processed))
                .filter(Boolean)
                .join('\n');
            break;
        case 'INTERSECTION':
        case 'TUPLE':
        case 'UNION':
            type = [
                hasStandaloneName(ast) ? generateStandaloneType(ast, options) : undefined,
                ast.params
                    .map(ast => declareNamedTypes(ast, options, rootASTName, processed))
                    .filter(Boolean)
                    .join('\n'),
                'spreadParam' in ast && ast.spreadParam
                    ? declareNamedTypes(ast.spreadParam, options, rootASTName, processed)
                    : undefined
            ]
                .filter(Boolean)
                .join('\n');
            break;
        default:
            if (hasStandaloneName(ast)) {
                type = generateStandaloneType(ast, options);
            }
    }
    return type;
}
function generateType(ast, options) {
    const type = generateRawType(ast, options);
    if (options.strictIndexSignatures && ast.keyName === '[k: string]') {
        return `${type} | undefined`;
    }
    return type;
}
function generateRawType(ast, options) {
    log('generator', ast);
    if (hasStandaloneName(ast)) {
        return toSafeString(ast.standaloneName);
    }
    switch (ast.type) {
        case 'ANY':
            return 'any';
        case 'ARRAY':
            return (() => {
                const type = generateType(ast.params, options);
                return type.endsWith('"') ? '(' + type + ')[]' : type + '[]';
            })();
        case 'BOOLEAN':
            return 'boolean';
        case 'INTERFACE':
            return generateInterface(ast, options);
        case 'INTERSECTION':
            return generateSetOperation(ast, options);
        case 'LITERAL':
            return JSON.stringify(ast.params);
        case 'NUMBER':
            return 'number';
        case 'NULL':
            return 'null';
        case 'OBJECT':
            return 'object';
        case 'REFERENCE':
            return ast.params;
        case 'STRING':
            return 'string';
        case 'TUPLE':
            return (() => {
                const minItems = ast.minItems;
                const maxItems = ast.maxItems || -1;
                let spreadParam = ast.spreadParam;
                const astParams = [...ast.params];
                if (minItems > 0 && minItems > astParams.length && ast.spreadParam === undefined) {
                    // this is a valid state, and JSONSchema doesn't care about the item type
                    if (maxItems < 0) {
                        // no max items and no spread param, so just spread any
                        spreadParam = exports.T_ANY;
                    }
                }
                if (maxItems > astParams.length && ast.spreadParam === undefined) {
                    // this is a valid state, and JSONSchema doesn't care about the item type
                    // fill the tuple with any elements
                    for (let i = astParams.length; i < maxItems; i += 1) {
                        astParams.push(exports.T_ANY);
                    }
                }
                function addSpreadParam(params) {
                    if (spreadParam) {
                        const spread = '...(' + generateType(spreadParam, options) + ')[]';
                        params.push(spread);
                    }
                    return params;
                }
                function paramsToString(params) {
                    return '[' + params.join(', ') + ']';
                }
                const paramsList = astParams.map(param => generateType(param, options));
                if (paramsList.length > minItems) {
                    /*
                  if there are more items than the min, we return a union of tuples instead of
                  using the optional element operator. This is done because it is more typesafe.
          
                  // optional element operator
                  type A = [string, string?, string?]
                  const a: A = ['a', undefined, 'c'] // no error
          
                  // union of tuples
                  type B = [string] | [string, string] | [string, string, string]
                  const b: B = ['a', undefined, 'c'] // TS error
                  */
                    const cumulativeParamsList = paramsList.slice(0, minItems);
                    const typesToUnion = [];
                    if (cumulativeParamsList.length > 0) {
                        // actually has minItems, so add the initial state
                        typesToUnion.push(paramsToString(cumulativeParamsList));
                    }
                    else {
                        // no minItems means it's acceptable to have an empty tuple type
                        typesToUnion.push(paramsToString([]));
                    }
                    for (let i = minItems; i < paramsList.length; i += 1) {
                        cumulativeParamsList.push(paramsList[i]);
                        if (i === paramsList.length - 1) {
                            // only the last item in the union should have the spread parameter
                            addSpreadParam(cumulativeParamsList);
                        }
                        typesToUnion.push(paramsToString(cumulativeParamsList));
                    }
                    return typesToUnion.join('|');
                }
                // no max items so only need to return one type
                return paramsToString(addSpreadParam(paramsList));
            })();
        case 'UNION':
            return generateSetOperation(ast, options);
        case 'CUSTOM_TYPE':
            return ast.params;
    }
}
/**
 * Generate a Union or Intersection
 */
function generateSetOperation(ast, options) {
    const members = ast.params.map(_ => generateType(_, options));
    const separator = ast.type === 'UNION' ? '|' : '&';
    return members.length === 1 ? members[0] : '(' + members.join(' ' + separator + ' ') + ')';
}
function generateInterface(ast, options) {
    return (`{` +
        '\n' +
        ast.params
            .filter(_ => !_.isPatternProperty && !_.isUnreachableDefinition)
            .map(({ isRequired, keyName, ast }) => [isRequired, keyName, ast, generateType(ast, options)])
            .map(([isRequired, keyName, ast, type]) => (hasComment(ast) && !ast.standaloneName ? generateComment(ast.comment) + '\n' : '') +
            escapeKeyName(keyName) +
            (isRequired ? '' : '?') +
            ': ' +
            (hasStandaloneName(ast) ? toSafeString(type) : type))
            .join('\n') +
        '\n' +
        '}');
}
function generateComment(comment) {
    return ['/**', ...comment.split('\n').map(_ => ' * ' + _), ' */'].join('\n');
}
function generateStandaloneEnum(ast, options) {
    return ((hasComment(ast) ? generateComment(ast.comment) + '\n' : '') +
        'export ' +
        (options.enableConstEnums ? 'const ' : '') +
        `enum ${toSafeString(ast.standaloneName)} {` +
        '\n' +
        ast.params.map(({ ast, keyName }) => keyName + ' = ' + generateType(ast, options)).join(',\n') +
        '\n' +
        '}');
}
function generateStandaloneInterface(ast, options) {
    return ((hasComment(ast) ? generateComment(ast.comment) + '\n' : '') +
        `export interface ${toSafeString(ast.standaloneName)} ` +
        (ast.superTypes.length > 0
            ? `extends ${ast.superTypes.map(superType => toSafeString(superType.standaloneName)).join(', ')} `
            : '') +
        generateInterface(ast, options));
}
function generateStandaloneType(ast, options) {
    return ((hasComment(ast) ? generateComment(ast.comment) + '\n' : '') +
        `export type ${toSafeString(ast.standaloneName)} = ${generateType(lodash_1.omit(ast, 'standaloneName') /* TODO */, options)}`);
}
function escapeKeyName(keyName) {
    if (keyName.length && /[A-Za-z_$]/.test(keyName.charAt(0)) && /^[\w$]+$/.test(keyName)) {
        return keyName;
    }
    if (keyName === '[k: string]') {
        return keyName;
    }
    return JSON.stringify(keyName);
}
function getSuperTypesAndParams(ast) {
    return ast.params.map(param => param.ast).concat(ast.superTypes);
}
function toSafeString(string) {
    // identifiers in javaScript/ts:
    // First character: a-zA-Z | _ | $
    // Rest: a-zA-Z | _ | $ | 0-9
    return lodash_1.upperFirst(
    // remove accents, umlauts, ... by their basic latin letters
    lodash_1.deburr(string)
        // replace chars which are not valid for typescript identifiers with whitespace
        .replace(/(^\s*[^a-zA-Z_$])|([^a-zA-Z_$\d])/g, ' ')
        // uppercase leading underscores followed by lowercase
        .replace(/^_[a-z]/g, match => match.toUpperCase())
        // remove non-leading underscores followed by lowercase (convert snake_case)
        .replace(/_[a-z]/g, match => match.substr(1, match.length).toUpperCase())
        // uppercase letters after digits, dollars
        .replace(/([\d$]+[a-zA-Z])/g, match => match.toUpperCase())
        // uppercase first letter after whitespace
        .replace(/\s+([a-zA-Z])/g, match => lodash_1.trim(match.toUpperCase()))
        // remove remaining whitespace
        .replace(/\s/g, ''));
}
exports.toSafeString = toSafeString;
function optimize(ast, processed = new Map()) {
    log('optimizer', ast, processed.has(ast) ? '(FROM CACHE)' : '');
    if (processed.has(ast)) {
        return processed.get(ast);
    }
    processed.set(ast, ast);
    switch (ast.type) {
        case 'INTERFACE':
            return Object.assign(ast, {
                params: ast.params.map(_ => Object.assign(_, { ast: optimize(_.ast, processed) }))
            });
        case 'INTERSECTION':
        case 'UNION':
            // [A, B, C, Any] -> Any
            if (ast.params.some(_ => _.type === 'ANY')) {
                log('optimizer', ast, '<- T_ANY');
                return exports.T_ANY;
            }
            // [A, B, B] -> [A, B]
            ast.params = lodash_1.uniqBy(ast.params, _ => `${_.type}------${stringify(_.params)}`);
            return Object.assign(ast, {
                params: ast.params.map(_ => optimize(_, processed))
            });
        default:
            return ast;
    }
}
exports.optimize = optimize;
function parse(schema, options, rootSchema = schema, keyName, isSchema = true, processed = new Map(), usedNames = new Set()) {
    // If we've seen this node before, return it.
    if (processed.has(schema)) {
        return processed.get(schema);
    }
    const definitions = getDefinitions(rootSchema);
    const keyNameFromDefinition = lodash_1.findKey(definitions, _ => _ === schema);
    // Cache processed ASTs before they are actually computed, then update
    // them in place using set(). This is to avoid cycles.
    // TODO: Investigate alternative approaches (lazy-computing nodes, etc.)
    const ast = {};
    processed.set(schema, ast);
    const set = (_ast) => Object.assign(ast, _ast);
    return isSchema
        ? parseNonLiteral(schema, options, rootSchema, keyName, keyNameFromDefinition, set, processed, usedNames)
        : parseLiteral(schema, keyName, keyNameFromDefinition, set);
}
exports.parse = parse;
function parseLiteral(schema, keyName, keyNameFromDefinition, set) {
    return set({
        keyName,
        params: schema,
        standaloneName: keyNameFromDefinition,
        type: 'LITERAL'
    });
}
/**
 * Duck types a JSONSchema schema or property to determine which kind of AST node to parse it into.
 */
function typeOfSchema(schema) {
    if (schema.tsType)
        return 'CUSTOM_TYPE';
    if (schema.allOf)
        return 'ALL_OF';
    if (schema.anyOf)
        return 'ANY_OF';
    if (schema.oneOf)
        return 'ONE_OF';
    if (Array.isArray(schema.type))
        return 'UNION';
    if (schema.type === 'null')
        return 'NULL';
    if (schema.items)
        return 'TYPED_ARRAY';
    if (schema.enum && schema.tsEnumNames)
        return 'NAMED_ENUM';
    if (schema.enum)
        return 'UNNAMED_ENUM';
    if (schema.$ref)
        return 'REFERENCE';
    switch (schema.type) {
        case 'string':
            return 'STRING';
        case 'number':
            return 'NUMBER';
        case 'integer':
            return 'NUMBER';
        case 'boolean':
            return 'BOOLEAN';
        case 'object':
            if (!schema.properties && !lodash_1.isPlainObject(schema)) {
                return 'OBJECT';
            }
            break;
        case 'array':
            return 'UNTYPED_ARRAY';
        case 'any':
            return 'ANY';
    }
    switch (typeof schema.default) {
        case 'boolean':
            return 'BOOLEAN';
        case 'number':
            return 'NUMBER';
        case 'string':
            return 'STRING';
    }
    if (schema.id)
        return 'NAMED_SCHEMA';
    if (lodash_1.isPlainObject(schema) && Object.keys(schema).length)
        return 'UNNAMED_SCHEMA';
    return 'ANY';
}
exports.typeOfSchema = typeOfSchema;
function parseNonLiteral(schema, options, rootSchema, keyName, keyNameFromDefinition, set, processed, usedNames) {
    log('parser', schema, '<-' + typeOfSchema(schema), processed.has(schema) ? '(FROM CACHE)' : '');
    switch (typeOfSchema(schema)) {
        case 'ALL_OF':
            return set({
                comment: schema.description,
                keyName,
                params: schema.allOf.map(_ => parse(_, options, rootSchema, undefined, true, processed, usedNames)),
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'INTERSECTION'
            });
        case 'ANY':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'ANY'
            });
        case 'ANY_OF':
            return set({
                comment: schema.description,
                keyName,
                params: schema.anyOf.map(_ => parse(_, options, rootSchema, undefined, true, processed, usedNames)),
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'UNION'
            });
        case 'BOOLEAN':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'BOOLEAN'
            });
        case 'CUSTOM_TYPE':
            return set({
                comment: schema.description,
                keyName,
                params: schema.tsType,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'CUSTOM_TYPE'
            });
        case 'NAMED_ENUM':
            return set({
                comment: schema.description,
                keyName,
                params: schema.enum.map((_, n) => ({
                    ast: parse(_, options, rootSchema, undefined, false, processed, usedNames),
                    keyName: schema.tsEnumNames[n]
                })),
                standaloneName: standaloneName(schema, keyName, usedNames),
                type: 'ENUM'
            });
        case 'NAMED_SCHEMA':
            return set(newInterface(schema, options, rootSchema, processed, usedNames, keyName));
        case 'NULL':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'NULL'
            });
        case 'NUMBER':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'NUMBER'
            });
        case 'OBJECT':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'OBJECT'
            });
        case 'ONE_OF':
            return set({
                comment: schema.description,
                keyName,
                params: schema.oneOf.map(_ => parse(_, options, rootSchema, undefined, true, processed, usedNames)),
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'UNION'
            });
        case 'REFERENCE':
            throw Error(format('Refs should have been resolved by the resolver!', schema));
        case 'STRING':
            return set({
                comment: schema.description,
                keyName,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'STRING'
            });
        case 'TYPED_ARRAY':
            if (Array.isArray(schema.items)) {
                // normalised to not be undefined
                const minItems = schema.minItems;
                const maxItems = schema.maxItems;
                const arrayType = {
                    comment: schema.description,
                    keyName,
                    maxItems,
                    minItems,
                    params: schema.items.map(_ => parse(_, options, rootSchema, undefined, true, processed, usedNames)),
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                    type: 'TUPLE'
                };
                if (schema.additionalItems === true) {
                    arrayType.spreadParam = {
                        type: 'ANY'
                    };
                }
                else if (schema.additionalItems) {
                    arrayType.spreadParam = parse(schema.additionalItems, options, rootSchema, undefined, true, processed, usedNames);
                }
                return set(arrayType);
            }
            else {
                const params = parse(schema.items, options, rootSchema, undefined, true, processed, usedNames);
                return set({
                    comment: schema.description,
                    keyName,
                    params,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                    type: 'ARRAY'
                });
            }
        case 'UNION':
            return set({
                comment: schema.description,
                keyName,
                params: schema.type.map(_ => parse(Object.assign(Object.assign({}, schema), { type: _ }), options, rootSchema, undefined, true, processed, usedNames)),
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'UNION'
            });
        case 'UNNAMED_ENUM':
            return set({
                comment: schema.description,
                keyName,
                params: schema.enum.map(_ => parse(_, options, rootSchema, undefined, false, processed, usedNames)),
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'UNION'
            });
        case 'UNNAMED_SCHEMA':
            return set(newInterface(schema, options, rootSchema, processed, usedNames, keyName, keyNameFromDefinition));
        case 'UNTYPED_ARRAY':
            // normalised to not be undefined
            const minItems = schema.minItems;
            const maxItems = typeof schema.maxItems === 'number' ? schema.maxItems : -1;
            const params = exports.T_ANY;
            if (minItems > 0 || maxItems >= 0) {
                return set({
                    comment: schema.description,
                    keyName,
                    maxItems: schema.maxItems,
                    minItems,
                    // create a tuple of length N
                    params: Array(Math.max(maxItems, minItems) || 0).fill(params),
                    // if there is no maximum, then add a spread item to collect the rest
                    spreadParam: maxItems >= 0 ? undefined : params,
                    standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                    type: 'TUPLE'
                });
            }
            return set({
                comment: schema.description,
                keyName,
                params,
                standaloneName: standaloneName(schema, keyNameFromDefinition, usedNames),
                type: 'ARRAY'
            });
    }
}
/**
 * Compute a schema name using a series of fallbacks
 */
function standaloneName(schema, keyNameFromDefinition, usedNames) {
    const name = schema.title || schema.id || keyNameFromDefinition;
    if (name) {
        return generateName(name, usedNames);
    }
}
function generateName(from, usedNames) {
    let name = toSafeString(from);
    // increment counter until we find a free name
    if (usedNames.has(name)) {
        let counter = 1;
        while (usedNames.has(name)) {
            name = `${toSafeString(from)}${counter}`;
            counter++;
        }
    }
    usedNames.add(name);
    return name;
}
exports.generateName = generateName;
function newInterface(schema, options, rootSchema, processed, usedNames, keyName, keyNameFromDefinition) {
    const name = standaloneName(schema, keyNameFromDefinition, usedNames);
    return {
        comment: schema.description,
        keyName,
        params: parseSchema(schema, options, rootSchema, processed, usedNames, name),
        standaloneName: name,
        superTypes: parseSuperTypes(schema, options, processed, usedNames),
        type: 'INTERFACE'
    };
}
function parseSuperTypes(schema, options, processed, usedNames) {
    // Type assertion needed because of dereferencing step
    // TODO: Type it upstream
    const superTypes = schema.extends;
    if (!superTypes) {
        return [];
    }
    if (Array.isArray(superTypes)) {
        return superTypes.map(_ => newNamedInterface(_, options, _, processed, usedNames));
    }
    return [newNamedInterface(superTypes, options, superTypes, processed, usedNames)];
}
function newNamedInterface(schema, options, rootSchema, processed, usedNames) {
    const namedInterface = newInterface(schema, options, rootSchema, processed, usedNames);
    if (hasStandaloneName(namedInterface)) {
        return namedInterface;
    }
    // TODO: Generate name if it doesn't have one
    throw Error(format('Supertype must have standalone name!', namedInterface));
}
/**
 * Helper to parse schema properties into params on the parent schema's type
 */
function parseSchema(schema, options, rootSchema, processed, usedNames, parentSchemaName) {
    let asts = lodash_1.map(schema.properties, (value, key) => ({
        ast: parse(value, options, rootSchema, key, true, processed, usedNames),
        isPatternProperty: false,
        isRequired: lodash_1.includes(schema.required || [], key),
        isUnreachableDefinition: false,
        keyName: key
    }));
    let singlePatternProperty = false;
    if (schema.patternProperties) {
        // partially support patternProperties. in the case that
        // additionalProperties is not set, and there is only a single
        // value definition, we can validate against that.
        singlePatternProperty = !schema.additionalProperties && Object.keys(schema.patternProperties).length === 1;
        asts = asts.concat(lodash_1.map(schema.patternProperties, (value, key) => {
            const ast = parse(value, options, rootSchema, key, true, processed, usedNames);
            const comment = `This interface was referenced by \`${parentSchemaName}\`'s JSON-Schema definition
via the \`patternProperty\` "${key}".`;
            ast.comment = ast.comment ? `${ast.comment}\n\n${comment}` : comment;
            return {
                ast,
                isPatternProperty: !singlePatternProperty,
                isRequired: singlePatternProperty || lodash_1.includes(schema.required || [], key),
                isUnreachableDefinition: false,
                keyName: singlePatternProperty ? '[k: string]' : key
            };
        }));
    }
    if (options.unreachableDefinitions) {
        asts = asts.concat(lodash_1.map(schema.definitions, (value, key) => {
            const ast = parse(value, options, rootSchema, key, true, processed, usedNames);
            const comment = `This interface was referenced by \`${parentSchemaName}\`'s JSON-Schema
via the \`definition\` "${key}".`;
            ast.comment = ast.comment ? `${ast.comment}\n\n${comment}` : comment;
            return {
                ast,
                isPatternProperty: false,
                isRequired: lodash_1.includes(schema.required || [], key),
                isUnreachableDefinition: true,
                keyName: key
            };
        }));
    }
    // handle additionalProperties
    switch (schema.additionalProperties) {
        case undefined:
        case true:
            if (singlePatternProperty) {
                return asts;
            }
            return asts.concat({
                ast: exports.T_ANY_ADDITIONAL_PROPERTIES,
                isPatternProperty: false,
                isRequired: true,
                isUnreachableDefinition: false,
                keyName: '[k: string]'
            });
        case false:
            return asts;
        // pass "true" as the last param because in TS, properties
        // defined via index signatures are already optional
        default:
            return asts.concat({
                ast: parse(schema.additionalProperties, options, rootSchema, '[k: string]', true, processed, usedNames),
                isPatternProperty: false,
                isRequired: true,
                isUnreachableDefinition: false,
                keyName: '[k: string]'
            });
    }
}
/**
 * TODO: Memoize
 */
function getDefinitions(schema, isSchema = true, processed = new Set()) {
    if (processed.has(schema)) {
        return {};
    }
    processed.add(schema);
    if (Array.isArray(schema)) {
        return schema.reduce((prev, cur) => (Object.assign(Object.assign({}, prev), getDefinitions(cur, false, processed))), {});
    }
    if (lodash_1.isPlainObject(schema)) {
        return Object.assign(Object.assign({}, (isSchema && hasDefinitions(schema) ? schema.definitions : {})), Object.keys(schema).reduce((prev, cur) => (Object.assign(Object.assign({}, prev), getDefinitions(schema[cur], false, processed))), {}));
    }
    return {};
}
/**
 * TODO: Reduce rate of false positives
 */
function hasDefinitions(schema) {
    return 'definitions' in schema;
}
const normalizer_rules = new Map();
function hasType(schema, type) {
    return schema.type === type || (Array.isArray(schema.type) && schema.type.includes(type));
}
function isObjectType(schema) {
    return schema.properties !== undefined || hasType(schema, 'object') || hasType(schema, 'any');
}
function isArrayType(schema) {
    return schema.items !== undefined || hasType(schema, 'array') || hasType(schema, 'any');
}
normalizer_rules.set('Remove `type=["null"]` if `enum=[null]`', schema => {
    if (Array.isArray(schema.enum) &&
        schema.enum.some(e => e === null) &&
        Array.isArray(schema.type) &&
        schema.type.includes('null')) {
        schema.type = schema.type.filter(type => type !== 'null');
    }
});
normalizer_rules.set('Destructure unary types', schema => {
    if (schema.type && Array.isArray(schema.type) && schema.type.length === 1) {
        schema.type = schema.type[0];
    }
});
normalizer_rules.set('Add empty `required` property if none is defined', schema => {
    if (!('required' in schema) && isObjectType(schema)) {
        schema.required = [];
    }
});
normalizer_rules.set('Transform `required`=false to `required`=[]', schema => {
    if (schema.required === false) {
        schema.required = [];
    }
});
// TODO: default to empty schema (as per spec) instead
normalizer_rules.set('Default additionalProperties to true', schema => {
    if (!('additionalProperties' in schema) && isObjectType(schema) && schema.patternProperties === undefined) {
        schema.additionalProperties = true;
    }
});
normalizer_rules.set('Default top level `id`', (schema, rootSchema, fileName) => {
    if (!schema.id && stringify(schema) === stringify(rootSchema)) {
        schema.id = toSafeString(justName(fileName));
    }
});
normalizer_rules.set('Escape closing JSDoc Comment', schema => {
    escapeBlockComment(schema);
});
/**
 * Eg. `foo/bar/baz.json` => `baz`
 */
function justName(filename = '') {
    return stripExtension(basename(filename));
}
exports.justName = justName;
/**
 * Avoid appending "js" to top-level unnamed schemas
 */
function stripExtension(filename) {
    return filename.replace(extname(filename), '');
}
exports.stripExtension = stripExtension;
/**
 * escape block comments in schema descriptions so that they don't unexpectedly close JSDoc comments in generated typescript interfaces
 */
function escapeBlockComment(schema) {
    const replacer = '* /';
    if (schema === null || typeof schema !== 'object') {
        return;
    }
    for (const key of Object.keys(schema)) {
        if (key === 'description' && typeof schema[key] === 'string') {
            schema[key] = schema[key].replace(/\*\//g, replacer);
        }
    }
}
exports.escapeBlockComment = escapeBlockComment;
normalizer_rules.set('Normalise schema.minItems', schema => {
    // make sure we only add the props onto array types
    if (isArrayType(schema)) {
        const { minItems } = schema;
        schema.minItems = typeof minItems === 'number' ? minItems : 0;
    }
    // cannot normalise maxItems because maxItems = 0 has an actual meaning
});
normalizer_rules.set('Normalize schema.items', schema => {
    const { maxItems, minItems } = schema;
    const hasMaxItems = typeof maxItems === 'number' && maxItems >= 0;
    const hasMinItems = typeof minItems === 'number' && minItems > 0;
    if (schema.items && !Array.isArray(schema.items) && (hasMaxItems || hasMinItems)) {
        const items = schema.items;
        // create a tuple of length N
        const newItems = Array(maxItems || minItems || 0).fill(items);
        if (!hasMaxItems) {
            // if there is no maximum, then add a spread item to collect the rest
            schema.additionalItems = items;
        }
        schema.items = newItems;
    }
    if (Array.isArray(schema.items) && hasMaxItems && maxItems < schema.items.length) {
        // it's perfectly valid to provide 5 item defs but require maxItems 1
        // obviously we shouldn't emit a type for items that aren't expected
        schema.items = schema.items.slice(0, maxItems);
    }
    return schema;
});
function normalize(schema, filename) {
    const _schema = lodash_1.cloneDeep(schema);
    normalizer_rules.forEach((rule, key) => {
        traverse(_schema, schema => rule(schema, _schema, filename));
        log('normalizer', `Applied rule: "${key}"`);
    });
    return _schema;
}
exports.normalize = normalize;
function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string')
        throw new TypeError('"ext" argument must be a string');
    // assertPath(path);
    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;
    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
        if (ext.length === path.length && ext === path)
            return '';
        var extIdx = ext.length - 1;
        var firstNonSlashEnd = -1;
        for (i = path.length - 1; i >= 0; --i) {
            var code = path.charCodeAt(i);
            if (code === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else {
                if (firstNonSlashEnd === -1) {
                    // We saw the first non-path separator, remember this index in case
                    // we need it if the extension ends up not matching
                    matchedSlash = false;
                    firstNonSlashEnd = i + 1;
                }
                if (extIdx >= 0) {
                    // Try to match the explicit extension
                    if (code === ext.charCodeAt(extIdx)) {
                        if (--extIdx === -1) {
                            // We matched the extension, so mark this as the end of our path
                            // component
                            end = i;
                        }
                    }
                    else {
                        // Extension does not match, so our result is the entire path
                        // component
                        extIdx = -1;
                        end = firstNonSlashEnd;
                    }
                }
            }
        }
        if (start === end)
            end = firstNonSlashEnd;
        else if (end === -1)
            end = path.length;
        return path.slice(start, end);
    }
    else {
        for (i = path.length - 1; i >= 0; --i) {
            if (path.charCodeAt(i) === 47 /*/*/) {
                // If we reached a path separator that was not part of a set of path
                // separators at the end of the string, stop now
                if (!matchedSlash) {
                    start = i + 1;
                    break;
                }
            }
            else if (end === -1) {
                // We saw the first non-path separator, mark this as the end of our
                // path component
                matchedSlash = false;
                end = i + 1;
            }
        }
        if (end === -1)
            return '';
        return path.slice(start, end);
    }
}
function extname(path) {
    // assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
                startPart = i + 1;
                break;
            }
            continue;
        }
        if (end === -1) {
            // We saw the first non-path separator, mark this as the end of our
            // extension
            matchedSlash = false;
            end = i + 1;
        }
        if (code === 46 /*.*/) {
            // If this is our first dot, mark it as the start of our extension
            if (startDot === -1)
                startDot = i;
            else if (preDotState !== 1)
                preDotState = 1;
        }
        else if (startDot !== -1) {
            // We saw a non-dot and non-path separator before our dot, so we should
            // have a good chance at having a non-empty extension
            preDotState = -1;
        }
    }
    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
        return '';
    }
    return path.slice(startDot, end);
}
//# sourceMappingURL=json_to_ts.js.map